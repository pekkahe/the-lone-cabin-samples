using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

/// <summary>
/// A* path finder which calculates the shortest path between two points.
/// </summary>
/// <remarks>
/// <para>
/// Calculates the shortest path from A to B using a formula F = G + H, where:
/// G = the movement cost to move from the starting point to a given point on the plane, following the
///     path generated to get there.
/// H = the estimated movement cost to move from that given point on the plane to the final destination.
/// The path with the lowest F score is chosen.
/// </para>
/// <para>
/// For reference see http://www.policyalmanac.org/games/aStarTutorial.htm.
/// </para>
/// </remarks>
public class AStarPathFinder
{
    private bool _isDone;
    private object _doneHandle = new object();
    private bool _isRunning;
    private object _runningHandle = new object();

    private Thread _thread;
    private VisibilityGraph _visibilityGraph;
    private AStarNode _startNode;
    private AStarNode _endNode;
    private LinkedList<AStarNode> _openList = new LinkedList<AStarNode>();
    private LinkedList<AStarNode> _closedList = new LinkedList<AStarNode>();

    /// <summary>
    /// The path from the start position to the end position as generated by
    /// the latest path finding, or null if no path was found.
    /// </summary>
    public Path Path { get; private set; }

    /// <summary>
    /// Indicates whether path finding is done and a <see cref="Path"/> is ready.
    /// </summary>
    public bool IsDone
    {
        get
        {
            var temp = false;
            lock (_doneHandle)
            {
                temp = _isDone;
            }
            return temp;
        }
        set
        {
            lock (_doneHandle)
            {
                _isDone = value;
            }
        }
    }

    /// <summary>
    /// Indicates whether a path finder worker thread is running.
    /// </summary>
    public bool IsRunning
    {
        get
        {
            var temp = false;
            lock (_runningHandle)
            {
                temp = _isRunning;
            }
            return temp;
        }
        set
        {
            lock (_runningHandle)
            {
                _isRunning = value;
            }
        }
    }

    public AStarPathFinder(VisibilityGraph visibilityGraph)
    {
        _visibilityGraph = visibilityGraph;
    }

    /// <summary>
    /// Starts the A* path finder which tries to find the shortest path from
    /// <c>startPosition</c> to <c>endPosition</c>. Returns immediately.
    /// </summary>
    public void Start(Vector3 startPosition, Vector3 endPosition)
    {
        if (IsRunning)
        {
            Debug.LogError("Path finder thread already running.");
            return;
        }

        // Create nodes for the start and end position
        _startNode = new AStarNode(startPosition);
        _endNode = new AStarNode(endPosition);

        // Add start and end nodes into the visibility graph
        _visibilityGraph.Add(_startNode);
        _visibilityGraph.Add(_endNode);

        // Start searching for a path in a separate thread
        _thread = new Thread(FindPath);
        _thread.Start();

        IsRunning = true;
    }

    public void Abort()
    {
        if (_thread != null)
            _thread.Abort();

        IsDone = true;
        IsRunning = false;
    }

    /// <summary>
    /// Path finding worker function. 
    /// </summary>
    /// <remarks>
    /// Threaded function. DON'T use the Unity API here, because it's not thread safe.
    /// </remarks>
    private void FindPath()
    {
        // Start by adding the start node to the open list
        _openList.AddFirst(_startNode);

        var endReached = false;
        while (!endReached)
        {
            endReached = SearchForPath();
        }

        var pathNodes = GetSortedPathNodes();

        // Get the waypoint vertices from the path nodes
        var vertices = new List<Vector3>();
        foreach (var node in pathNodes)
            vertices.Add(node.Position);

        // Create a new path representing the found waypoints. Note that if the path finding failed,
        // the last waypoint in the list does not point to target position. Therefore, we pass it explicitly.
        Path = new Path(vertices, _endNode.Position);

        if (HasFailedToFindTarget())
            Path.IsValid = false;

        IsRunning = false;
        IsDone = true;
    }

    /// <summary>
    /// The core of the A* algorithm logic. Processes a single node per call, which is the most propable
    ///	one (closest to target) from a list of unchecked nodes. Checks its adjacent nodes for other propable
    ///	nodes and adds them into the list to be checked. Returns true if end has been reached, or false if 
    /// path finding should be continued.
    /// </summary>
    /// <returns>True if current node is the target node or if there are no more nodes to check.</returns>
    private bool SearchForPath()
    {
        // 1. Get the lowest F cost node from the open list and set is as current.
        //    The open list is kept sorted by F cost, so just return the first value from the list.
        var current = _openList.First.Value;

        // 2. Switch the node to the closed list
        SwitchToClosedList(current);

        // 3. Add visible/reachable nodes to the open list, if they are not already in the closed list.
        //    Also, if a node is already in the open list, check if the current path is better.
        var visibilityMap = _visibilityGraph.Get(current);

        foreach (var node in visibilityMap)
        {
            // Ignore nodes which are already in the closed list
            if (_closedList.Contains(node))
                continue;

            // If node is already on the open list check if current path
            // to that node is a better one, using G cost as measure
            if (_openList.Contains(node))
                CalculateAlternativeCost(node, current);
            else
                AddToOpenList(node, current);
        }

        // 4. Stop when the current node is the target node, 
        //    or if we fail to find the target meaning the open list is empty. 
        return HasFoundTarget(current) || HasFailedToFindTarget();
    }

    private bool HasFoundTarget(AStarNode node)
    {
        return node == _endNode;
    }

    private bool HasFailedToFindTarget()
    {
        return _openList.Count == 0;
    }

    private void SwitchToClosedList(AStarNode node)
    {
        _openList.Remove(node);
        _closedList.AddLast(node);
    }

    private void CalculateAlternativeCost(AStarNode node, AStarNode current)
    {
        var alternativeGCost = CalculateAlternativeGCost(node, current);

        // If the alternative G cost is lower, change the visible node's
        // parent to the current node and recalculate G cost
        if (alternativeGCost < node.G)
        {
            node.Parent = current;
            node.G = alternativeGCost;
        }
    }

    private void AddToOpenList(AStarNode node, AStarNode current)
    {
        // Make the current node this node's parent and calculate the G and H scores
        node.Parent = current;
        node.G = CalculateGCost(node);
        node.H = CalculateHCost(node.Position, _endNode.Position);

        // Keep the open list sorted by adding the new node before 
        // a node which has an equal or higher F cost
        foreach (var openNode in _openList)
        {
            if (node.F < openNode.F)
            {
                var listNode = _openList.Find(openNode);

                _openList.AddBefore(listNode, node);
                return;
            }
        }

        // If open list is empty, just add to the end
        _openList.AddLast(node);
    }

    private float CalculateGCost(AStarNode node)
    {
        return (node.Parent.Position - node.Position).magnitude + node.Parent.G;
    }

    private float CalculateHCost(Vector3 position, Vector3 destination)
    {
        return (position - destination).magnitude;
    }

    private float CalculateAlternativeGCost(AStarNode node, AStarNode current)
    {
        return (current.Position - node.Position).magnitude + node.G;
    }

    private List<AStarNode> GetSortedPathNodes()
    {
        var pathNodes = new List<AStarNode>();

        // Add end node to list as a starting point
        var current = _closedList.Last.Value;

        pathNodes.Add(current);

        // Form path by starting from end and traversing to beginning through parent nodes 
        while (current.Parent != null)
        {
            current = current.Parent;

            pathNodes.Add(current);
        }

        // Reverse list so that it reflects a path from start to end
        pathNodes.Reverse();

        return pathNodes;
    }
}
